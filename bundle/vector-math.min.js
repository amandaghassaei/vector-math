!function(t,s){"object"==typeof exports&&"undefined"!=typeof module?s(exports):"function"==typeof define&&define.amd?define(["exports"],s):s((t="undefined"!=typeof globalThis?globalThis:t||self).VECTOR_MATH={})}(this,(function(t){"use strict";let s=1e-15;function i(){return s}function e(){try{throw new Error("")}catch(t){const s=(t.stack||"").split("\n").map((t=>t.trim()));return s.splice(0,2),s.join("\n")}}class h{constructor(t,s){this.x=t||0,this.y=s||0}set(t,s){return this.x=t,this.y=s,this}setFromArray(t){return this.x=t[0],this.y=t[1],this}add(t){return this.x+=t.x,this.y+=t.y,this}sub(t){return this.x-=t.x,this.y-=t.y,this}multiplyScalar(t){return this.x*=t,this.y*=t,this}divideScalar(t){return Math.abs(t)<=i()&&console.warn(`Dividing by zero in Vector2.divideScalar(), stack trace:\n${e()}.`),this.multiplyScalar(1/t)}dot(t){return this.x*t.x+this.y*t.y}static dot(t,s){return t.x*s.x+t.y*s.y}cross(t){return this.x*t.y-this.y*t.x}static cross(t,s){return t.x*s.y-t.y*s.x}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}lengthSq(){return this.dot(this)}length(){return Math.sqrt(this.lengthSq())}distanceToSquared(t){const s=this.x-t.x,i=this.y-t.y;return s*s+i*i}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}normalize(){let t=this.length();return t<=i()&&(console.warn(`Attempting to normalize zero length Vector2, stack trace:\n${e()}.`),t=1),this.divideScalar(t),this}applyMatrix3(t){if(t.isIdentity)return this;const s=this.x,i=this.y,e=t.elements;return this.x=e[0]*s+e[1]*i+e[2],this.y=e[3]*s+e[4]*i+e[5],this}lerp(t,s){return this.x+=(t.x-this.x)*s,this.y+=(t.y-this.y)*s,this}average(t){return this.x=(this.x+t.x)/2,this.y=(this.y+t.y)/2,this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this}invert(){return this.x=-this.x,this.y=-this.y,this}angleTo(t){const s=this.dot(t)/Math.sqrt(this.lengthSq()*t.lengthSq());return Math.acos(Math.min(Math.max(s,-1),1))}static angleTo(t,s){const i=h.dot(t,s)/Math.sqrt(t.lengthSq()*s.lengthSq());return Math.acos(Math.min(Math.max(i,-1),1))}angleToNormalized(t){const s=this.dot(t);return Math.acos(Math.min(Math.max(s,-1),1))}static angleToNormalized(t,s){const i=h.dot(t,s);return Math.acos(Math.min(Math.max(i,-1),1))}copy(t){return this.x=t.x,this.y=t.y,this}equals(t){return Math.abs(this.x-t.x)<=i()&&Math.abs(this.y-t.y)<=i()}static equals(t,s){return Math.abs(t.x-s.x)<=i()&&Math.abs(t.y-s.y)<=i()}isZero(){return Math.abs(this.x)<=i()&&Math.abs(this.y)<=i()}clone(){return new h(this.x,this.y)}toArray(){return[this.x,this.y]}}class r{constructor(t,s,i){this.x=t||0,this.y=s||0,this.z=i||0}set(t,s,i){return this.x=t,this.y=s,this.z=i,this}setFromArray(t){return this.x=t[0],this.y=t[1],this.z=t[2],this}add(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this}sub(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this}divideScalar(t){return Math.abs(t)<=i()&&console.warn(`Dividing by zero in Vector3.divideScalar(), stack trace:\n${e()}.`),this.multiplyScalar(1/t)}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}static dot(t,s){return t.x*s.x+t.y*s.y+t.z*s.z}cross(t){const s=this.x,i=this.y,e=this.z,h=t.x,r=t.y,n=t.z;return this.x=i*n-e*r,this.y=e*h-s*n,this.z=s*r-i*h,this}lengthSq(){return this.dot(this)}length(){return Math.sqrt(this.lengthSq())}distanceToSquared(t){const s=this.x-t.x,i=this.y-t.y,e=this.z-t.z;return s*s+i*i+e*e}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}normalize(){let t=this.length();return t<=i()&&(console.warn(`Attempting to normalize zero length Vector3, stack trace:\n${e()}.`),t=1),this.divideScalar(t),this}applyMatrix4(t){if(t.isIdentity)return this;const s=this.x,i=this.y,e=this.z,h=t.elements;return this.x=h[0]*s+h[1]*i+h[2]*e+h[3],this.y=h[4]*s+h[5]*i+h[6]*e+h[7],this.z=h[8]*s+h[9]*i+h[10]*e+h[11],this}applyMatrix4RotationComponent(t){if(t.isIdentity)return this;const s=this.x,i=this.y,e=this.z,h=t.elements;return this.x=h[0]*s+h[1]*i+h[2]*e,this.y=h[4]*s+h[5]*i+h[6]*e,this.z=h[8]*s+h[9]*i+h[10]*e,this}applyQuaternion(t){const s=this.x,i=this.y,e=this.z,h=t.x,r=t.y,n=t.z,a=t.w,o=a*s+r*e-n*i,y=a*i+n*s-h*e,u=a*e+h*i-r*s,l=-h*s-r*i-n*e;return this.x=o*a+l*-h+y*-n-u*-r,this.y=y*a+l*-r+u*-h-o*-n,this.z=u*a+l*-n+o*-r-y*-h,this}lerp(t,s){return this.x+=(t.x-this.x)*s,this.y+=(t.y-this.y)*s,this.z+=(t.z-this.z)*s,this}average(t){return this.x=(this.x+t.x)/2,this.y=(this.y+t.y)/2,this.z=(this.z+t.z)/2,this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this}invert(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}angleTo(t){const s=this.dot(t)/Math.sqrt(this.lengthSq()*t.lengthSq());return Math.acos(Math.min(Math.max(s,-1),1))}angleToNormalized(t){const s=this.dot(t);return Math.acos(Math.min(Math.max(s,-1),1))}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}equals(t){return Math.abs(this.x-t.x)<=i()&&Math.abs(this.y-t.y)<=i()&&Math.abs(this.z-t.z)<=i()}static equals(t,s){return Math.abs(t.x-s.x)<=i()&&Math.abs(t.y-s.y)<=i()&&Math.abs(t.z-s.z)<=i()}isZero(){return this.x<=i()&&this.y<=i()&&this.z<=i()}clone(){return new r(this.x,this.y,this.z)}toArray(){return[this.x,this.y,this.z]}}class n{constructor(t,s,i,e,h,r,a){void 0!==t?(this._elements=[t,s,i,e,h,r],this._isIdentity=void 0===a?n._checkElementForIdentity(this._elements):a):(this._elements=[1,0,0,0,1,0],this._isIdentity=!0)}set elements(t){throw new Error("No elements setter on Matrix3.")}get elements(){return this._elements}set isIdentity(t){throw new Error("No isIdentity setter on Matrix3.")}get isIdentity(){return this._isIdentity}_set(t,s,i,e,h,r){const{_elements:n}=this;return n[0]=t,n[1]=s,n[2]=i,n[3]=e,n[4]=h,n[5]=r,this}setIdentity(){return this._set(1,0,0,0,1,0),this._isIdentity=!0,this}static _checkElementForIdentity(t){const[s,e,h,r,n,a]=t;return Math.abs(s-1)<=i()&&Math.abs(n-1)<=i()&&Math.abs(e)<=i()&&Math.abs(h)<=i()&&Math.abs(r)<=i()&&Math.abs(a)<=i()}setFromRotationTranslation(t,s){if(Math.abs(t)<=i()&&Math.abs(s.x)<=i()&&Math.abs(s.y)<=i())return this.setIdentity();const e=Math.cos(t),h=-Math.sin(t),r=-h,n=e,a=s.x*e+s.y*h,o=s.x*r+s.y*n;return this._set(e,h,a,r,n,o),this._isIdentity=!1,this}equals(t){const s=this.elements,e=t.elements;for(let t=0,h=s.length;t<h;t++)if(Math.abs(s[t]-e[t])>i())return!1;return!0}copy(t){const{elements:s}=t;return this._set(s[0],s[1],s[2],s[3],s[4],s[5]),this._isIdentity=t.isIdentity,this}clone(){const{_elements:t}=this;return new n(t[0],t[1],t[2],t[3],t[4],t[5],this._isIdentity)}}const a=new r;class o{constructor(t,s,i,e,h,r,n,a,y,u,l,x,c){void 0!==t?(this._elements=[t,s,i,e,h,r,n,a,y,u,l,x],this._isIdentity=void 0===c?o._checkElementsForIdentity(this._elements):c):(this._elements=[1,0,0,0,0,1,0,0,0,0,1,0],this._isIdentity=!0)}set elements(t){throw new Error("No elements setter on Matrix4.")}get elements(){return this._elements}set isIdentity(t){throw new Error("No isIdentity setter on Matrix4.")}get isIdentity(){return this._isIdentity}static _checkElementsForIdentity(t){const[s,e,h,r,n,a,o,y,u,l,x,c]=t;return Math.abs(s-1)<=i()&&Math.abs(a-1)<=i()&&Math.abs(x-1)<=i()&&Math.abs(e)<=i()&&Math.abs(h)<=i()&&Math.abs(r)<=i()&&Math.abs(n)<=i()&&Math.abs(o)<=i()&&Math.abs(y)<=i()&&Math.abs(u)<=i()&&Math.abs(l)<=i()&&Math.abs(c)<=i()}_set(t,s,i,e,h,r,n,a,o,y,u,l){const{_elements:x}=this;return x[0]=t,x[1]=s,x[2]=i,x[3]=e,x[4]=h,x[5]=r,x[6]=n,x[7]=a,x[8]=o,x[9]=y,x[10]=u,x[11]=l,this}setIdentity(){return this._set(1,0,0,0,0,1,0,0,0,0,1,0),this._isIdentity=!0,this}premultiplyMatrix4(t){return o._multiplyMatrices(this,t,this)}multiplyMatrix4(t){return o._multiplyMatrices(this,this,t)}static _multiplyMatrices(t,s,i){if(s.isIdentity)return t.copy(i);if(i.isIdentity)return t.copy(s);const{_elements:e}=t,h=s.elements,r=i.elements,n=h[0],a=h[1],y=h[2],u=h[3],l=h[4],x=h[5],c=h[6],_=h[7],d=h[8],M=h[9],m=h[10],z=h[11],g=r[0],p=r[1],b=r[2],w=r[3],I=r[4],f=r[5],S=r[6],q=r[7],T=r[8],v=r[9],A=r[10],E=r[11];return e[0]=n*g+a*I+y*T,e[1]=n*p+a*f+y*v,e[2]=n*b+a*S+y*A,e[3]=n*w+a*q+y*E+u,e[4]=l*g+x*I+c*T,e[5]=l*p+x*f+c*v,e[6]=l*b+x*S+c*A,e[7]=l*w+x*q+c*E+_,e[8]=d*g+M*I+m*T,e[9]=d*p+M*f+m*v,e[10]=d*b+M*S+m*A,e[11]=d*w+M*q+m*E+z,t._isIdentity=o._checkElementsForIdentity(e),t}setTranslation(t){return Math.abs(t.x)<=i()&&Math.abs(t.y)<=i()&&Math.abs(t.z)<=i()?this.setIdentity():(this._set(1,0,0,t.x,0,1,0,t.y,0,0,1,t.z),this._isIdentity=!1,this)}setRotationAxisAngleAtOffset(t,s,e){if(Math.abs(s)<=i())return this.setIdentity();const h=Math.cos(s),r=Math.sin(s);return this._setRotationAxisCosSin(h,r,t,e)}setRotationFromVectorToVector(t,s,e){if(r.equals(t,s))return this.setIdentity();const h=a.copy(t).cross(s);let n=h.length();if(n<=i()){n=0,h.set(t.y,-t.x,0);let s=h.length();s<=i()&&(h.set(-t.z,0,t.x),s=h.length()),h.divideScalar(s)}else h.divideScalar(n);const o=r.dot(t,s);return this._setRotationAxisCosSin(o,n,h,e)}setReflectionNormalAtOffset(t,s){const i=t.x,e=t.y,h=t.z,r=1-2*i*i,n=-2*i*e,a=-2*i*h,o=n,y=1-2*e*e,u=-2*e*h,l=a,x=u,c=1-2*h*h;return s?this._setRotationMatrixAtOffset(r,n,a,o,y,u,l,x,c,s):this._set(r,n,a,0,o,y,u,0,l,x,c,0),this._isIdentity=!1,this}_setRotationAxisCosSin(t,s,i,e){const h=1-t,r=i.x,n=i.y,a=i.z,o=h*r,y=h*n,u=o*r+t,l=o*n-s*a,x=o*a+s*n,c=o*n+s*a,_=y*n+t,d=y*a-s*r,M=o*a-s*n,m=y*a+s*r,z=h*a*a+t;return e?this._setRotationMatrixAtOffset(u,l,x,c,_,d,M,m,z,e):this._set(u,l,x,0,c,_,d,0,M,m,z,0),this._isIdentity=!1,this}_setRotationMatrixAtOffset(t,s,i,e,h,r,n,a,o,y){const u=-y.x*(t-1)-y.y*s-y.z*i,l=-y.x*e-y.y*(h-1)-y.z*r,x=-y.x*n-y.y*a-y.z*(o-1);this._set(t,s,i,u,e,h,r,l,n,a,o,x)}invertTransform(){if(this._isIdentity)return this;const{_elements:t}=this,s=t[0],i=t[4],e=t[8],h=t[1],r=t[5],n=t[9],a=t[2],o=t[6],y=t[10],u=t[3],l=t[7],x=t[11],c=-s*u-i*l-e*x,_=-h*u-r*l-n*x,d=-a*u-o*l-y*x;return this._set(s,i,e,c,h,r,n,_,a,o,y,d),this}equals(t){const s=this.elements,e=t.elements;for(let t=0,h=s.length;t<h;t++)if(Math.abs(s[t]-e[t])>i())return!1;return!0}copy(t){const{elements:s}=t;return this._set(s[0],s[1],s[2],s[3],s[4],s[5],s[6],s[7],s[8],s[9],s[10],s[11]),this._isIdentity=t.isIdentity,this}clone(){const{_elements:t}=this;return new o(t[0],t[1],t[2],t[3],t[4],t[5],t[6],t[7],t[8],t[9],t[10],t[11],this._isIdentity)}}class y{constructor(t,s,i,e){this._x=t||0,this._y=s||0,this._z=i||0,this._w=void 0!==e?e:1}set x(t){throw new Error("No x setter on Quaternion.")}get x(){return this._x}set y(t){throw new Error("No y setter on Quaternion.")}get y(){return this._y}set z(t){throw new Error("No z setter on Quaternion.")}get z(){return this._z}set w(t){throw new Error("No w setter on Quaternion.")}get w(){return this._w}setFromUnitVectors(t,s){let i=t.x*s.x+t.y*s.y+t.z*s.z+1;return i<=Number.EPSILON?(i=0,Math.abs(t.x)>Math.abs(t.z)?(this._x=-t.y,this._y=t.x,this._z=0,this._w=i):(this._x=0,this._y=-t.z,this._z=t.y,this._w=i)):(this._x=t.y*s.z-t.z*s.y,this._y=t.z*s.x-t.x*s.z,this._z=t.x*s.y-t.y*s.x,this._w=i),this.normalize()}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this.lengthSq())}normalize(){let t=this.length();return t<=i()?(console.warn(`Attempting to normalize zero length Quaternion, stack trace:\n${e()}.`),this._x=0,this._y=0,this._z=0,this._w=1):(t=1/t,this._x=this._x*t,this._y=this._y*t,this._z=this._z*t,this._w=this._w*t),this}multiply(t){return y._multiplyQuaternions(this,this,t)}premultiply(t){return y._multiplyQuaternions(this,t,this)}static _multiplyQuaternions(t,s,i){const e=s.x,h=s.y,r=s.z,n=s.w,a=i.x,o=i.y,y=i.z,u=i.w;return t._x=e*u+n*a+h*y-r*o,t._y=h*u+n*o+r*a-e*y,t._z=r*u+n*y+e*o-h*a,t._w=n*u-e*a-h*o-r*y,t}copy(t){return this._x=t.x,this._y=t.y,this._z=t.z,this._w=t.w,this}clone(){return new y(this._x,this._y,this._z,this._w)}}t.DEFAULT_NUMERICAL_TOLERANCE=1e-15,t.Matrix3=n,t.Matrix4=o,t.Quaternion=y,t.Vector2=h,t.Vector3=r,t.clampValue=function(t,s,i){return Math.max(Math.min(t,i),s)},t.degreesToRadians=function(t){return t/180*Math.PI},t.radiansToDegrees=function(t){return 180*t/Math.PI},t.roundValueToIncrement=function(t,s){var i;if(0===s)return t;if(s<0)throw new Error(`Invalid coarse step: ${s}.`);const e=Math.round(t/s)*s,h=(null===(i=s.toString().split(".")[1])||void 0===i?void 0:i.length)||0;return parseFloat(e.toFixed(h))},t.setNumericalTolerance=function(t){s=t}}));
//# sourceMappingURL=vector-math.min.js.map
